#pragma kernel CSMain
#pragma kernel EdgeDetection

// Size of the buffers
#define WIDTH 640
#define HEIGHT 480

// Number of frames
int num_frames;

// Buffers
RWStructuredBuffer<float> depth_ar;
RWStructuredBuffer<float> optical_ar;
RWStructuredBuffer<float> depth_buffer;
RWStructuredBuffer<float> optical_buffer;

// buffer pos
int buffer_pos;

// averaging
bool mean_averaging;

int calc_pre_buffer_pos(int pos)
{
    if (pos == 0)
    {
        return num_frames - 1;
    }
    else
    {
        return pos - 1;
    }
}

[numthreads(16, 16, 1)]
void CSMain(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;
    int index = xIndex + yIndex * WIDTH;
    
    optical_buffer[buffer_pos * WIDTH * HEIGHT + index] = optical_ar[index];
    optical_buffer[(buffer_pos + num_frames) * WIDTH * HEIGHT + index] = optical_ar[index + WIDTH * HEIGHT];
    
    if (xIndex > 20 && xIndex < WIDTH - 1 && yIndex > 45 && yIndex < HEIGHT - 1 - 45)
    {
        if (mean_averaging)
        {
            depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = depth_ar[index];
            float weighted_sum = 0.0;
            float total_weight = 0.0001;
 
            for (int i = 0; i < num_frames - 1; i++)
            {
                int idx = i * WIDTH * HEIGHT + index;
                if (depth_buffer[idx] > 0)
                {
                    weighted_sum += depth_buffer[idx];
                    total_weight += 1.0;
                }
            }
            
            depth_ar[index] = weighted_sum / total_weight;
        }
        else
        {
            float total_weight = 1.0f;
            float total_depth = depth_ar[index];
            int current_pos = buffer_pos;
            int current_xindex = xIndex;
            int current_yindex = yIndex;
        
            for (int i = 0; i < num_frames - 1; ++i)
            {
                int pre_pos = calc_pre_buffer_pos(current_pos);
            
                float optical_flow_x = optical_buffer[current_pos * WIDTH * HEIGHT + index];
                float optical_flow_y = optical_buffer[(current_pos + num_frames) * WIDTH * HEIGHT + index];

                int prev_x = current_xindex - int(optical_flow_x);
                int prev_y = current_yindex - int(optical_flow_y);

                if (prev_x > 20 && prev_x < WIDTH - 1 && prev_y > 45 && prev_y < HEIGHT - 1 - 45)
                {
                    int prev_index = prev_x + prev_y * WIDTH;

                    float prev_depth = depth_buffer[pre_pos * WIDTH * HEIGHT + prev_index];

                    if (prev_depth >= 0.1f)
                    {
                        total_weight = total_weight + 0.3f;
                        total_depth = total_depth + prev_depth * 0.3f;
                    }
                }
            
                current_xindex = prev_x;
                current_yindex = prev_y;
                current_pos = pre_pos;

            }
        
            float final_depth = total_depth / total_weight;
        
            depth_ar[index] = final_depth;
            depth_buffer[buffer_pos * WIDTH * HEIGHT + index] = final_depth;
        }

    }
    
}

// EdgeDetection
[numthreads(16, 16, 1)]
void EdgeDetection(uint3 groupId : SV_GroupID, uint3 threadId : SV_GroupThreadID)
{
    int xIndex = groupId.x * 16 + threadId.x;
    int yIndex = groupId.y * 16 + threadId.y;

    int index = xIndex + yIndex * WIDTH;

    if (xIndex > 0 && xIndex < WIDTH - 1 && yIndex > 0 && yIndex < HEIGHT - 1)
    {
        float gradX = depth_ar[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                    //+ depth_ar[(xIndex    ) + (yIndex + 1) * WIDTH] * 0.0
                    + depth_ar[(xIndex + 1) + (yIndex + 1) * WIDTH] * 1.0
                    + depth_ar[(xIndex) + (yIndex) * WIDTH] * -2.0
                    //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                    + depth_ar[(xIndex + 1) + (yIndex) * WIDTH] * 2.0
                    + depth_ar[(xIndex - 1) + (yIndex - 1) * WIDTH] * -1.0
                    //+ depth_ar[(xIndex    ) + (yIndex - 1) * WIDTH] * 0.0
                    + depth_ar[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;
            
        float gradY = depth_ar[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                    + depth_ar[(xIndex) + (yIndex + 1) * WIDTH] * -2.0
                    + depth_ar[(xIndex + 1) + (yIndex + 1) * WIDTH] * -1.0
                    //+ depth_ar[(xIndex    ) + (yIndex    ) * WIDTH] * 0.0
                    //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                    //+ depth_ar[(xIndex + 1) + (yIndex    ) * WIDTH] * 0.0
                    + depth_ar[(xIndex - 1) + (yIndex - 1) * WIDTH] * 1.0
                    + depth_ar[(xIndex) + (yIndex - 1) * WIDTH] * 2.0
                    + depth_ar[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;

        float temp = gradX * gradX + gradY * gradY;

        if (temp >= 0.0 && sqrt(temp) > 0.5f)
        {
            depth_ar[index] = 0.0;
        }
    }
}