#pragma kernel CSMain
#pragma kernel EdgeDetector

struct MeshProperties
{
    float4 pos;
};

#define WIDTH 640
#define HEIGHT 480

RWStructuredBuffer<MeshProperties> _Properties;
RWStructuredBuffer<float3> _Depth;
RWStructuredBuffer<float> _Sparse;
RWStructuredBuffer<float> _Edge;
RWStructuredBuffer<float3> _ICP_Res;
float4x4 _GOPose;
float4x4 _ICPTrans;
float4 intrinsics;
float4 screenData;
float samplingSize;
float t;
float y_max;
float z_max;
bool show_sampling_res;

float edgeThreshold;
int maxNeighbourNum;
bool activate_edge_detection;

float meanThreshold;


#define TILE_SIZE 16
#define BORDER_SIZE 2
#define SHARED_SIZE (TILE_SIZE + 2 * BORDER_SIZE)

groupshared float sharedDepth[SHARED_SIZE][SHARED_SIZE];

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void EdgeDetector(uint3 id : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID, uint3 groupID : SV_GroupID)
{
    uint indexX = id.x;
    uint indexY = id.y;
    uint index = indexY * WIDTH + indexX;
    
    // Local thread indices within the group
    uint localX = groupThreadID.x;
    uint localY = groupThreadID.y;
    
    // Calculate shared memory coordinates
    uint sharedX = localX + BORDER_SIZE;
    uint sharedY = localY + BORDER_SIZE;
    
    // Load center tile data
    if (indexX < WIDTH && indexY < HEIGHT)
    {
        sharedDepth[sharedY][sharedX] = _Depth[index].z;
    }
    else
    {
        sharedDepth[sharedY][sharedX] = 0.0f;
    }
    
    // Load border data - top border
    if (localY < BORDER_SIZE)
    {
        int borderY = (int)indexY - BORDER_SIZE;
        if (borderY >= 0 && indexX < WIDTH)
        {
            uint borderIndex = borderY * WIDTH + indexX;
            sharedDepth[localY][sharedX] = _Depth[borderIndex].z;
        }
        else
        {
            sharedDepth[localY][sharedX] = 0.0f;
        }
    }
    
    // Load border data - bottom border
    if (localY >= TILE_SIZE - BORDER_SIZE)
    {
        int borderY = (int)indexY + BORDER_SIZE;
        if (borderY < HEIGHT && indexX < WIDTH)
        {
            uint borderIndex = borderY * WIDTH + indexX;
            uint sharedBorderY = localY + 2 * BORDER_SIZE;
            sharedDepth[sharedBorderY][sharedX] = _Depth[borderIndex].z;
        }
        else
        {
            uint sharedBorderY = localY + 2 * BORDER_SIZE;
            sharedDepth[sharedBorderY][sharedX] = 0.0f;
        }
    }
    
    // Load border data - left border
    if (localX < BORDER_SIZE)
    {
        int borderX = (int)indexX - BORDER_SIZE;
        if (borderX >= 0 && indexY < HEIGHT)
        {
            uint borderIndex = indexY * WIDTH + borderX;
            sharedDepth[sharedY][localX] = _Depth[borderIndex].z;
        }
        else
        {
            sharedDepth[sharedY][localX] = 0.0f;
        }
    }
    
    // Load border data - right border
    if (localX >= TILE_SIZE - BORDER_SIZE)
    {
        int borderX = (int)indexX + BORDER_SIZE;
        if (borderX < WIDTH && indexY < HEIGHT)
        {
            uint borderIndex = indexY * WIDTH + borderX;
            uint sharedBorderX = localX + 2 * BORDER_SIZE;
            sharedDepth[sharedY][sharedBorderX] = _Depth[borderIndex].z;
        }
        else
        {
            uint sharedBorderX = localX + 2 * BORDER_SIZE;
            sharedDepth[sharedY][sharedBorderX] = 0.0f;
        }
    }
    
    // Load corner data - top-left
    if (localX < BORDER_SIZE && localY < BORDER_SIZE)
    {
        int borderX = (int)indexX - BORDER_SIZE;
        int borderY = (int)indexY - BORDER_SIZE;
        if (borderX >= 0 && borderY >= 0)
        {
            uint borderIndex = borderY * WIDTH + borderX;
            sharedDepth[localY][localX] = _Depth[borderIndex].z;
        }
        else
        {
            sharedDepth[localY][localX] = 0.0f;
        }
    }
    
    // Load corner data - top-right
    if (localX >= TILE_SIZE - BORDER_SIZE && localY < BORDER_SIZE)
    {
        int borderX = (int)indexX + BORDER_SIZE;
        int borderY = (int)indexY - BORDER_SIZE;
        if (borderX < WIDTH && borderY >= 0)
        {
            uint borderIndex = borderY * WIDTH + borderX;
            uint sharedBorderX = localX + 2 * BORDER_SIZE;
            sharedDepth[localY][sharedBorderX] = _Depth[borderIndex].z;
        }
        else
        {
            uint sharedBorderX = localX + 2 * BORDER_SIZE;
            sharedDepth[localY][sharedBorderX] = 0.0f;
        }
    }
    
    // Load corner data - bottom-left
    if (localX < BORDER_SIZE && localY >= TILE_SIZE - BORDER_SIZE)
    {
        int borderX = (int)indexX - BORDER_SIZE;
        int borderY = (int)indexY + BORDER_SIZE;
        if (borderX >= 0 && borderY < HEIGHT)
        {
            uint borderIndex = borderY * WIDTH + borderX;
            uint sharedBorderY = localY + 2 * BORDER_SIZE;
            sharedDepth[sharedBorderY][localX] = _Depth[borderIndex].z;
        }
        else
        {
            uint sharedBorderY = localY + 2 * BORDER_SIZE;
            sharedDepth[sharedBorderY][localX] = 0.0f;
        }
    }
    
    // Load corner data - bottom-right
    if (localX >= TILE_SIZE - BORDER_SIZE && localY >= TILE_SIZE - BORDER_SIZE)
    {
        int borderX = (int)indexX + BORDER_SIZE;
        int borderY = (int)indexY + BORDER_SIZE;
        if (borderX < WIDTH && borderY < HEIGHT)
        {
            uint borderIndex = borderY * WIDTH + borderX;
            uint sharedBorderX = localX + 2 * BORDER_SIZE;
            uint sharedBorderY = localY + 2 * BORDER_SIZE;
            sharedDepth[sharedBorderY][sharedBorderX] = _Depth[borderIndex].z;
        }
        else
        {
            uint sharedBorderX = localX + 2 * BORDER_SIZE;
            uint sharedBorderY = localY + 2 * BORDER_SIZE;
            sharedDepth[sharedBorderY][sharedBorderX] = 0.0f;
        }
    }
    
    // Wait for all threads to finish loading data
    GroupMemoryBarrierWithGroupSync();
    
    // Perform edge detection using shared memory
    if (indexX >= BORDER_SIZE && indexX < WIDTH - BORDER_SIZE && 
        indexY >= BORDER_SIZE && indexY < HEIGHT - BORDER_SIZE)
    {
        if (activate_edge_detection)
        {
            const float kX[5][5] =
            {
                { 1, 2, 0, -2, -1 },
                { 4, 8, 0, -8, -4 },
                { 6, 12, 0, -12, -6 },
                { 4, 8, 0, -8, -4 },
                { 1, 2, 0, -2, -1 }
            };

            const float kY[5][5] =
            {
                { 1, 4, 6, 4, 1 },
                { 2, 8, 12, 8, 2 },
                { 0, 0, 0, 0, 0 },
                { -2, -8, -12, -8, -2 },
                { -1, -4, -6, -4, -1 }
            };

            const float kMu[5][5] =
            {
                { 1, 1, 1, 1, 1 },
                { 1, 1, 1, 1, 1 },
                { 1, 1, 1, 1, 1 },
                { 1, 1, 1, 1, 1 },
                { 1, 1, 1, 1, 1 }
            };

            float Gx = 0.0;
            float Gy = 0.0;
            float mu = 0.0;

            // Use shared memory for convolution
            for (int i = -2; i <= 2; i++)
            {
                for (int j = -2; j <= 2; j++)
                {
                    uint sharedSampleX = sharedX + j;
                    uint sharedSampleY = sharedY + i;

                    float depthValue = sharedDepth[sharedSampleY][sharedSampleX];

                    Gx += depthValue * kX[i + 2][j + 2];
                    Gy += depthValue * kY[i + 2][j + 2];
                    mu += depthValue * kMu[i + 2][j + 2];
                }
            }
            
            if (sqrt(Gx * Gx + Gy * Gy) > edgeThreshold)
            {
                _Edge[index] = 1.0f;
            }
            else
            {
                _Edge[index] = 0.0f;
            }

            // Use shared memory for mean threshold check
            float currentDepth = sharedDepth[sharedY][sharedX];
            float meanDepth = mu / 25.0;
            if (abs(currentDepth - meanDepth) / meanDepth > meanThreshold)
            {
                _Edge[index] = 1.0f;
            }
        }
        else
        {
            _Edge[index] = 0.0f;
        }
    }
    else if (indexX < WIDTH && indexY < HEIGHT)
    {
        _Edge[index] = 1.0f;
    }
}

//float dx;
//float dy;
//float dz;

// We used to just be able to use (1, 1, 1) threads for whatever population (not sure the old limit), but a Unity update
// imposed a thread limit of 65535.  Now, to populations above that, we need to be more granular with our threads.
[numthreads(256, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x < 480 * 640)
    {
        
        float3 pos = _Depth[id.x];

        //float i = samplingSize * id.x;
        float i = id.x * samplingSize;

        float col_y = floor(i * screenData.z);
        float col_x = floor(i - col_y * screenData.x);
        //_Properties[id.x].color.z = 1

        uint depth_idx = (screenData.x * (screenData.y - col_y - 1)) + (screenData.x - col_x - 1);
    
        pos.z = _Depth[depth_idx].z * t + (1 - t);

        pos.x = (col_y - intrinsics.y) * pos.z / intrinsics.z;
        pos.y = (col_x - intrinsics.x) * pos.z / intrinsics.w;
        
        float4 final_pos = mul(_GOPose, float4(pos, 1.0f));

        float flg = 0.0f;

        //pos.z = _Depth[depth_idx];
        //pos.w = 1;
        //float4 pos = {.x,_Properties[id.x].pos.y,_Properties[id.x].pos.z,1.0};
        
        if (pos.y < y_max || pos.z < z_max)
        {
            pos.z = _Sparse[depth_idx] * t + (1 - t);
            pos.x = (col_y - intrinsics.y) * pos.z / intrinsics.z;
            pos.y = (col_x - intrinsics.x) * pos.z / intrinsics.w;

            flg = 1.0f;
        }
        
        _Properties[id.x].pos = final_pos;
        _Properties[id.x].pos.w = pos.z * t + (1 - t);
        
        if (_Edge[depth_idx] > 0.5f)
        {
            flg = 1.0f;
        }

        //float4 final_pos = mul(_GOPose, pos);
        //float4 final_pos1 = mul(_ICPTrans, final_pos);
        //float4 final_pos = pos;

        //final_pos.x = final_pos.x + dx;
        //final_pos.y = final_pos.y + dy;
        //final_pos.z = final_pos.z + dz;


    
    //if (pos.y < 0.5f || pos.z < -0.0f)
    //{
    //    pos.y = 0.0f;
    //    pos.z = 0.0f;
    //    pos.x = 0.0f;
    //    pos.w = 0.0f;
    //}
    
    // Apply translation to existing matrix, which will be read in the shader.
        //_Properties[id.x].pos = final_pos1;

        if (flg < 0.5f)
        {
            //_Properties[id.x].pos.w = _Depth[depth_idx] * t + (1 - t);
        }
        else
        {
            pos.z = _Sparse[depth_idx] * t + (1 - t);
            float4 final_pos_sparse = mul(_GOPose, float4(pos, 1.0f));
            _Properties[id.x].pos = final_pos_sparse;
            _Properties[id.x].pos.w = _Sparse[depth_idx] * t + (1 - t);
        }
        
    
        
        //if (show_sampling_res)
        //{
        //    if (id.x % 16 == 0)
        //    {
            
        //        _Properties[id.x].pos.x = _ICP_Res[id.x / 16].x;
        //        _Properties[id.x].pos.y = _ICP_Res[id.x / 16].y;
        //        _Properties[id.x].pos.z = _ICP_Res[id.x / 16].z;
        //        _Properties[id.x].pos.w = _Sparse[depth_idx] * t + (1 - t);
        //    }
        //    else
        //    {
        //        _Properties[id.x].pos.x = 1000.0f;
        //        _Properties[id.x].pos.y = 1000.0f;
        //        _Properties[id.x].pos.z = 1000.0f;
        //        _Properties[id.x].pos.w = 0.0f;
        //    }
        //}


        
    //_Properties[id.x].pos.w = abs(id.x * samplingSize - i);
    }
}