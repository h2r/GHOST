#pragma kernel CSMain

struct MeshProperties
{
    float4 pos;
};

#define WIDTH 640
#define HEIGHT 480

RWStructuredBuffer<MeshProperties> _Properties;
RWStructuredBuffer<float> _Depth;
RWStructuredBuffer<float> _Sparse;
float4x4 _GOPose;
float4x4 _ICPTrans;
float4 intrinsics;
float4 screenData;
float samplingSize;
float t;
float y_max;
float z_max;

float edgeThreshold;
bool activate_edge_detection;

//float dx;
//float dy;
//float dz;

// We used to just be able to use (1, 1, 1) threads for whatever population (not sure the old limit), but a Unity update
// imposed a thread limit of 65535.  Now, to populations above that, we need to be more granular with our threads.
[numthreads(256, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x < 480 * 640)
    {
        float4 pos = _Properties[id.x].pos;

        //float i = samplingSize * id.x;
        float i = id.x * samplingSize;

        float col_y = floor(i * screenData.z);
        float col_x = i - floor(i * screenData.z) * screenData.x;
        //_Properties[id.x].color.z = 1

        uint depth_idx = (screenData.x * (screenData.y - col_y - 1)) + (screenData.x - col_x - 1);
    
        pos.z = _Depth[depth_idx] * t + (1 - t);

        pos.x = (col_y - intrinsics.y) * pos.z / intrinsics.z;
        pos.y = (col_x - intrinsics.x) * pos.z / intrinsics.w;

        float flg = 0.0f;

        //pos.z = _Depth[depth_idx];
        pos.w = 1;
        //float4 pos = {.x,_Properties[id.x].pos.y,_Properties[id.x].pos.z,1.0};

        if (activate_edge_detection)
        {
            int xIndex = int(col_x);
            int yIndex = int(col_y);
            float gradX = _Depth[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                //+ depth_ar[(xIndex    ) + (yIndex + 1) * WIDTH] * 0.0
                + _Depth[(xIndex + 1) + (yIndex + 1) * WIDTH] * 1.0
                + _Depth[(xIndex) + (yIndex) * WIDTH] * -2.0
                //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                + _Depth[(xIndex + 1) + (yIndex) * WIDTH] * 2.0
                + _Depth[(xIndex - 1) + (yIndex - 1) * WIDTH] * -1.0
                //+ depth_ar[(xIndex    ) + (yIndex - 1) * WIDTH] * 0.0
                + _Depth[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;
            
            float gradY = _Depth[(xIndex - 1) + (yIndex + 1) * WIDTH] * -1.0
                + _Depth[(xIndex) + (yIndex + 1) * WIDTH] * -2.0
                + _Depth[(xIndex + 1) + (yIndex + 1) * WIDTH] * -1.0
                //+ depth_ar[(xIndex    ) + (yIndex    ) * WIDTH] * 0.0
                //+ depth_ar[(xIndex - 1) + (yIndex    ) * WIDTH] * 0.0
                //+ depth_ar[(xIndex + 1) + (yIndex    ) * WIDTH] * 0.0
                + _Depth[(xIndex - 1) + (yIndex - 1) * WIDTH] * 1.0
                + _Depth[(xIndex) + (yIndex - 1) * WIDTH] * 2.0
                + _Depth[(xIndex + 1) + (yIndex - 1) * WIDTH] * 1.0;

            float temp = gradX * gradX + gradY * gradY;

            if (temp >= 0.0 && sqrt(temp) > edgeThreshold)
            {
                flg = 1.0f;
            }
        }
        
        if (pos.y < y_max || pos.z < z_max)
        {
            pos.z = _Sparse[depth_idx] * t + (1 - t);
            pos.x = (col_y - intrinsics.y) * pos.z / intrinsics.z;
            pos.y = (col_x - intrinsics.x) * pos.z / intrinsics.w;

            flg = 1.0f;
        }

        float4 final_pos = mul(_GOPose, pos);
        float4 final_pos1 = mul(_ICPTrans, final_pos);
        //float4 final_pos = pos;

        //final_pos.x = final_pos.x + dx;
        //final_pos.y = final_pos.y + dy;
        //final_pos.z = final_pos.z + dz;


    
    //if (pos.y < 0.5f || pos.z < -0.0f)
    //{
    //    pos.y = 0.0f;
    //    pos.z = 0.0f;
    //    pos.x = 0.0f;
    //    pos.w = 0.0f;
    //}
    
    // Apply translation to existing matrix, which will be read in the shader.
        _Properties[id.x].pos = final_pos1;

        if (flg < 0.5f)
        {
            _Properties[id.x].pos.w = _Depth[depth_idx] * t + (1 - t);
        }
        else
        {
            _Properties[id.x].pos.w = _Sparse[depth_idx] * t + (1 - t);
        }

        
    //_Properties[id.x].pos.w = abs(id.x * samplingSize - i);
    }
}